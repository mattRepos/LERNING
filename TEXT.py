text = '''я бы хотел попасть на работу в big tech 
компании и заниматься серьезными задачми'''
print(text, end="\n\n")    # можно выводить большие тексты
                           # которые заключены в тройные кавычки и они будут выводиться построчно
s1 = "Python"
s2 = " learn"
print(s1+s2)  # конкатенация строк
              # строки можно соединять только со строками, если надо соеденить с числом
              # --> надо привести к строке (str)
              # можно выводить множественно строки с помощью оператор * после которого идет целого числа
print("ha"*5)
              # с помошью оператора in можно найти что то в строке или файле или чем то другом
ab = "ab"
abra = "abracadabra"
find = ab in abra
print(find)
              # можно сравнивать строки, но будет лексиграфический анализ
              # можно также опредить код символа с помощью ord()
              # в строке можно обращаться к ее индексам через имя_строки[номер_индекса]
              # также можно обращаться через отрицательные индексы которые идут с -1 и до конца (-1 соотв. последнему симв)
print(abra[-1])
print(abra[-2])

# ------СРЕЗЫ СТРОКИ
sr = "hello"
print(sr[::2])   # срез строки определяется параметрами [С какого: ДО какого: с КАКИМ шагом] если шаг 2-->вывод через один
                 # если не указывать вообще никакие параметры то будет такой же объект как и исходный
                 # в срезах можно использовать и отрицательные символы

print(sr[2:-1])  # при исползовании отрицательного среза в шаге --> можно перебрать в обратном порядке всю строку
                # срезы работают также и с массивами (list)
                # строке неизменяемый объект, она заменяемый объект

# ------МЕТОДЫ СТРОК
                 # вызов методов строк происходит с помощью обращения через точку name_str.
s = "python"
s1=s.upper()       # возведение всей строки в верхний регистр
s2=s.lower()       # перевод всей строки в нижний регистр
s3=s.split         # удаление пробелов и отступов в строке (есть rstrip и lstrip справа и слева соотв)
s4=s.count("py",0,5)  # поиск подстроки в строке, также есть 2 доп параметра, которые не явл обязательными
print(s4)          # данные параметры это индексы С который и ДО какой будут искаться подстрока
s5 = s.find("th")   # ищет где-то в строке и возвращает индекс первого вхождения, два параметра как и с предыдущим методом
print(s5)          # если не находится подстрока, то метод find возвращает ВСЕГДА -1
s6= s.replace("o","a")  #заменяет в строке все части строки
                                    # которые указываются первым арг, на второй арг,3-й аргумент опр макс кол-во замен
print(s6)
s7 = s.isalpha()     #проверка строки состоит ли она полностью из букв
s8 = s.isdigit()     #проверка строки состоит ли она полностью из цифр
s9 = s.rjust(2)      #возвращает новую строку (опр кол-во символов), второй аргумент указывается в качестве заполнителя
                     #если символов просто не хватает
print(s9)            #есть похожий метод ljust, если укажем меньшее кол-во чем длина строки -- вернет такую же строку
S = "Иванов Иван Иванович"
S1 = S.split(" ")    #разбиение строки по символу, который указывается в качестве аргумента, возвращается список и субстрок
print(S1)
S2 = " ".join(S1)
print(S2)

# ------ФОРМАТИРОВАНИЕ СТРОК

name = "Vasya"
age = 19
print(f"Ma name is {name} and I am {age}")  #использование f-строк, аргументы просто вставляются в строку
print(f"Ma name is {name.upper()} and I am {age*2}")  #можно использовать различные методы для аргументов

# ------СПИСКИ

city = ["Москва", "Вологда"]  #пример двух списков. Список - упорядоченная коллекция данных, чтение можно производить
marks = [2, 3, 4, 3, 5, 2]    #мгновенно, а добавление будет производить с O(n)
print(marks[2])               #обращение идет следующим образом, отрицательные индексы тоже работают
mid = sum(marks)/len(marks)   #методы списка есть следующие. sum просто сумм. все элементы, len - длина списка
print(mid)
marks[0] = 5                  #обращение и замена переменной с любым имеющимся индексом делается так
print(marks)
#marks[1] = "удовлетворительно"#список может содержать вообще разные типы данных от int до bool или вообще другие списки
print(marks)
                              #создать пустой списко можно так:
a = []
b = list()                    #функция list возвращает нам соотв список, здесь же он просто возвращает пустой список
                              #если указать какие то значения или передавать другой список, то можно создать новый или копию
# b = list([True,False])
# b = list("python")           #можно передать короче любой перебираемый/итерируемый объект

                             #для списков есть методы len,max,min,sum,sorted (это кншн не полный список методов списков)
print(sorted(marks))         #sorted() возвращает новый список, который не зависит от изначального списка
                             #у сортед есть второй аргемент reverse нужен для обратного порядка
                             #списки можно дублировать с помощью *n где n - сколько надо дублировать
print(city*3)

# ------СРЕЗЫ И СРАВНЕНИЯ СПИСКОВ
lst = ["Moscow", "Ufa", "Tver", "Kazan"]
print(lst[1:3])             #выделаются все элементы ДО указанного значения, оно НЕ включается
                            #с помощью срезов получается новый списко не зависящий от начального
                            #значит если ничего не указывать, то можно получить новый список, копию исходного

#В ОБЩЕМ ТО СРЕЗЫ СПИСКОВ РАБОТАЮТ РОВНО ПО ТАКОМУ ЖЕ ПРИНЦИПУ ЧТО И У СТРОК

marks[2:4]= ["хорошо", "удовлетворительно"]  #изменение значений группы элементов списка
                            # cписки сравниваются подобно строкам, нельзя сравнить число со строкой в списках
                            # можно сравнить строки со строками и числа с числами

# ------ОСНОВНЫЕ МЕТОДЫ СПИСКА

a = [1, -54, 2, 100, 50, 0, 120]
a.append(1000)              #добавление в конец нового элемента
print(a)                    #если делать a=a.append() -- потеряем список целиком, так делать НЕЛЬЗЯ
                            #append принимает только ОДИН аргумент
a.insert(2,-100)     #вставляем элемент, первый аргумент - КУДА, второй - ЧТО вставляем
a.remove(True)              #Можно удалить какой то элементв, если удалять bool значени, то может удалиться 0 или 1(F\T)
print(a)
                            #если удалить что то несуществующее -- будет ОШИБКА
b = a.pop()                 #pop удаляет и возвращает последнее с конца значение из списка
print(b)
print(a.pop(2))             #можно удалить какой то элемент по индексу из списка (в скобках пишется индекс)
#a.clear()                  #если надо очистить вообще весь список

C = a.copy()                #создает копию списка, в результате получается другой список, а не ссылается на имеющийся
print(a.count(100))         #ищет кол-во элементов в списке, которые указываются в скобках
print(a.index(100))         #возвращает индкс первого взождения, если указать второй аргумент
                            # - поиск будет производиться с этого значения

a.reverse()                 #переворачивает спискок
a.sort()                    #ничего не возвращает, только сортирует ТЕКУЩИЙ список,присваивать чему-то НЕЛЬЗЯ

# ------ВЛОЖЕННЫЕ, МНОГОМЕРНЫЕ СПИСКИ

img = [[1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3], [1, 7, 6, 11, 3]]
# или же можно сделать так:
line = [1, 7, 6, 11, 3]
img = [line[:],line[:],line[:],line[:],line[:]]
print(img)                  #многомерные список - список в списке
                            #обращение к вложенным спискам происходит через вторые [] скобки
print(img[0][2])            #вот пример обращения к вложенному списку
                            #все приколы со списками применимы и к вложенным спискам
img[1][:] = [1]*5           #переназначение всех значений второго вложенного списка
print(img)

