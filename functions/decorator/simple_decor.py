def func_decorator(func):
    def wrapper():
        print("------------------- что то до вызова функции")
        func()
        print("------------------- что то после вызова функции")

    return wrapper


def some_func():
    print("func_func func func")


some_func = func_decorator(some_func)  # some_func как бы меняет свою работу и расширяет свой функционал
some_func()

# вот декоратор в своем простом виде, суть заключается в том, что могут выполняться какие то действия до вызова функции
# до и после может что-то выполняться. Это по-сути своей расширяет функционал какой то функции.
# Но получается так, что данный декоратор имеет как бы частный случай, а не общий, далее будет более унив-й вариант
print()
print()


def func_decorator1(func1):
    def wrapper(*args, **kwargs):
        print("------------------- что то до вызова функции")
        func1(*args, **kwargs)
        print("------------------- что то после вызова функции")

    return wrapper


def some_func1(title):
    print(f"title = {title}")


some_func1 = func_decorator1(some_func1)
some_func1("arbuz arbuz")
# данный вариант являеется более универсальным, он может принимать произвольное кол-во аргументов и ничего не будет
# ломаться так просто, как это было с прошлым вариантом
# вместо явного декорирования в тупую, можно использовать @имя_декоратора в итоге не надо просто прописывать 37,38 строки