from functools import wraps # импорт для вызова декоратора, который сохраняет имя и описание исходной функции
import math


def df_decorator(dx = 0.001):
    def func_decorator(func):
        @wraps(func)    # можно делать вот так, вместо того, чтобы не писать строчки лишние для __doc__ и __name__
        def wrapper(x, *args, **kwargs):
            res = (func(x+dx, *args, **kwargs) - func(x, *args, **kwargs))/ dx
            return res

        #wrapper.__name__ = func.__name__ # это делается для того, чтобы не было "потери имени функции"
# дело в том, что при декорировании имя вызываемой функции изменяется на внут. функцию декоратора, что не есть хорошо
# для того, чтобы это не произошло есть вот такой подход, подход в лоб.
# тоже самое и с описанием [метод .__doc__]
        return wrapper
    return func_decorator
# вот как пример идет определение декоратора с параметрами. Тут в качестве параметра идет точность производной
# мы как бы делаем НАДфункцию и передаем через нее параметр, но все также идет вызов функции wrapper и так далее
# по сути, мы делаем ещё одну обертку над декоратором и потом этой оберткой декорируем какую то функцию
@df_decorator(dx = 0.001)
def sin_df(x):
    return math.sin(x)


df = sin_df(math.pi/3)
print(df)