def os_path(disk, *args,
            **kwargs):  # если функция будет принимать неопр кол-во аргументов --> достаточно прописать *args в арг-х
    print(args)
    print(kwargs)
    args = (disk,) + args
    path = kwargs['sep'].join(args)
    return path


p = os_path('F:', 'stepik.org', 'Курс по PYTHON', '\\функции.docx', sep='\\')
print(p)

# *args олицетворяет фактические параметры функции
# но если начать передавать функции произвольное число именнованных аргументов --> будет ошибка
# чтобы это исправить надо прописать в аргументах функции **kwargs (передача произв числа именнованных арг-в)
# формальные параметры должны идти непосредственно перед **kwargs, иначе будет ошибка, тоже самое с формальными
# параметрами и *args
# args --> позиционные арг-ы, kwargs --> именнованные

# *args ---> кортеж *kwargs ---> словарь
# * и ** можно использовать при работе с разными коллекциями
# можно реализовать это вот так. x будет ссылаться на первое значение, а y на все остальные и будет коллекцией

x, *y = (1, 2, 3, 4)  # ну или можно сделать наоборот, также можно это с любыми итер объектами
print(x)
print(y)
# мы не можем упаковать упакованные значения, будет ошибка
# *x = 1, 2, 3 -- ошибка, а если *x,y = 1, 2, 3 -- не будет ошибки. Упаковывать, то, что уже упак-о -- НЕЛЬЗЯ
# также операторы эти могут и РАСПАКОВЫВАТЬ

a = [1, 2, 3]
res = (*a,)  # распаковка списка в кортеж, без нее будет кортеж содержащий список
print(res)
d = (-5, 5)
print(list(range(*d)))  # можно сделать и так, распаковали кортеж, получили диап, преобразовали в список

# если для словарей указывать операторы распаковки через {*d.values()}, например, то получим множество состоящее из знач
# или же можем получить множество из пар ключ--значений с помощью {*d.items()}
# можно объеденить два словаря d1 и d2, например, с помощью {**d1, **d2}
