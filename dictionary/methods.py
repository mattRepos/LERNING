lst = ['+7', '+6', '+5', '+4']
a = dict.fromkeys(lst)          #создание словаря с заданием ключей, которые берутся из списка
print(a)                        # значение будет всегда None, если не задавать в методе второй аргумент

a = dict.fromkeys(lst, 'код страны')  #например вот так
print(a)
a.clear()                       # очистка словаря
print(a)
a.copy()                        # создание копии, именно копии, метод дублируется изначальный словаря
                                # если передавать в dict тоже словарь, то будет создана копия
d = {'house':'дом', 'car':'mashina', 'tree':'derevo', 'road':'doroga', 'river':'reka'}
print(d.get('arbuz arbuz', 'hehe'))      # при использовании такого метода, то если нет ключа - будет None, а не ошибка
                                # если указать второй аргумент, то он будет выводиться вместо None
d.setdefault('nums',[4,5,3])    #возвратит None, но также создаст новую пару, где значение будет None, если добавить второй аргумент в метод
# то будет создана пара с значением из второго аргумента, и это же значение вернется если нет такой пары
print(d)
d.pop('3', False)               # то же самое как и в списках, если же удалить несуществующий ключ - будет ошибка, НО
                                # если указать второй аргумент, то метод pop вернет, что указано во втором аргументе
print(d.keys())                 # метод возвращает список ключей из словаря
print(d.values())               # метод возвращает список значений из словаря
print(d.items())                # метод возвращает кортеж пар ключ--значение из словаря
d2 = {'car':'tachka', 'tree':'drevo', 'road':'wosse', 'river':'rechka'}
d.update(d2)                    # обновляет словарь и перезаписывает все совпадающие ключи
print(d)                        # т.е ключ из d2 совпал с d - обновляем значение
d3 = {**d, **d2}                # объединение словарей
print(d3)                       #сначала добавляется первый аргумент, а на него сверху после накатывается второй арг
                                # d | d2 - тоже объединение, но это новый синтаксис, на старых не будет работать